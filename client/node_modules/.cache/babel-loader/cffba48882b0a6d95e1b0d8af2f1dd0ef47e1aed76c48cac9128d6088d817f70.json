{"ast":null,"code":"var $8zHUo$sortablejs = require(\"sortablejs\");\nvar $8zHUo$classnames = require(\"classnames\");\nvar $8zHUo$react = require(\"react\");\nvar $8zHUo$tinyinvariant = require(\"tiny-invariant\");\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function (key) {\n    if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) {\n      return;\n    }\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      }\n    });\n  });\n  return dest;\n}\n$parcel$export(module.exports, \"Sortable\", () => $882b6d93070905b3$re_export$Sortable);\n$parcel$export(module.exports, \"Direction\", () => $882b6d93070905b3$re_export$Direction);\n$parcel$export(module.exports, \"DOMRect\", () => $882b6d93070905b3$re_export$DOMRect);\n$parcel$export(module.exports, \"GroupOptions\", () => $882b6d93070905b3$re_export$GroupOptions);\n$parcel$export(module.exports, \"MoveEvent\", () => $882b6d93070905b3$re_export$MoveEvent);\n$parcel$export(module.exports, \"Options\", () => $882b6d93070905b3$re_export$Options);\n$parcel$export(module.exports, \"PullResult\", () => $882b6d93070905b3$re_export$PullResult);\n$parcel$export(module.exports, \"PutResult\", () => $882b6d93070905b3$re_export$PutResult);\n$parcel$export(module.exports, \"SortableEvent\", () => $882b6d93070905b3$re_export$SortableEvent);\n$parcel$export(module.exports, \"SortableOptions\", () => $882b6d93070905b3$re_export$SortableOptions);\n$parcel$export(module.exports, \"Utils\", () => $882b6d93070905b3$re_export$Utils);\n$parcel$export(module.exports, \"ReactSortable\", () => $7fe8e3ea572bda7a$export$11bbed9ee0012c13);\nfunction $eb03e74f8f7db1f3$export$1d0aa160432dfea5(node) {\n  if (node.parentElement !== null) node.parentElement.removeChild(node);\n}\nfunction $eb03e74f8f7db1f3$export$6d240faa51aa562f(parent, newChild, index) {\n  const refChild = parent.children[index] || null;\n  parent.insertBefore(newChild, refChild);\n}\nfunction $eb03e74f8f7db1f3$export$d7d742816c28cf91(customs) {\n  $eb03e74f8f7db1f3$export$77f49a256021c8de(customs);\n  $eb03e74f8f7db1f3$export$a6177d5829f70ebc(customs);\n}\nfunction $eb03e74f8f7db1f3$export$77f49a256021c8de(customs) {\n  customs.forEach(curr => $eb03e74f8f7db1f3$export$1d0aa160432dfea5(curr.element));\n}\nfunction $eb03e74f8f7db1f3$export$a6177d5829f70ebc(customs) {\n  customs.forEach(curr => {\n    $eb03e74f8f7db1f3$export$6d240faa51aa562f(curr.parentElement, curr.element, curr.oldIndex);\n  });\n}\nfunction $eb03e74f8f7db1f3$export$4655efe700f887a(evt, list) {\n  const mode = $eb03e74f8f7db1f3$export$1fc0f6205829e19c(evt);\n  const parentElement = {\n    parentElement: evt.from\n  };\n  let custom = [];\n  switch (mode) {\n    case \"normal\":\n      /* eslint-disable */const item = {\n        element: evt.item,\n        newIndex: evt.newIndex,\n        oldIndex: evt.oldIndex,\n        parentElement: evt.from\n      };\n      custom = [item];\n      break;\n    case \"swap\":\n      const drag = {\n        element: evt.item,\n        oldIndex: evt.oldIndex,\n        newIndex: evt.newIndex,\n        ...parentElement\n      };\n      const swap = {\n        element: evt.swapItem,\n        oldIndex: evt.newIndex,\n        newIndex: evt.oldIndex,\n        ...parentElement\n      };\n      custom = [drag, swap];\n      break;\n    case \"multidrag\":\n      custom = evt.oldIndicies.map((curr, index) => ({\n        element: curr.multiDragElement,\n        oldIndex: curr.index,\n        newIndex: evt.newIndicies[index].index,\n        ...parentElement\n      }));\n      break;\n  }\n  /* eslint-enable */\n  const customs = $eb03e74f8f7db1f3$export$bc06a3af7dc65f53(custom, list);\n  return customs;\n}\nfunction $eb03e74f8f7db1f3$export$c25cf8080bd305ec(normalized, list) {\n  const a = $eb03e74f8f7db1f3$export$be2da95e6167b0bd(normalized, list);\n  const b = $eb03e74f8f7db1f3$export$eca851ee65ae17e4(normalized, a);\n  return b;\n}\nfunction $eb03e74f8f7db1f3$export$be2da95e6167b0bd(normalized, list) {\n  const newList = [...list];\n  normalized.concat().reverse().forEach(curr => newList.splice(curr.oldIndex, 1));\n  return newList;\n}\nfunction $eb03e74f8f7db1f3$export$eca851ee65ae17e4(normalized, list, evt, clone) {\n  const newList = [...list];\n  normalized.forEach(curr => {\n    const newItem = clone && evt && clone(curr.item, evt);\n    newList.splice(curr.newIndex, 0, newItem || curr.item);\n  });\n  return newList;\n}\nfunction $eb03e74f8f7db1f3$export$1fc0f6205829e19c(evt) {\n  if (evt.oldIndicies && evt.oldIndicies.length > 0) return \"multidrag\";\n  if (evt.swapItem) return \"swap\";\n  return \"normal\";\n}\nfunction $eb03e74f8f7db1f3$export$bc06a3af7dc65f53(inputs, list) {\n  const normalized = inputs.map(curr => ({\n    ...curr,\n    item: list[curr.oldIndex]\n  })).sort((a, b) => a.oldIndex - b.oldIndex);\n  return normalized;\n}\nfunction $eb03e74f8f7db1f3$export$7553c81e62e31b7e(props) {\n  /* eslint-disable */const {\n    list:\n    // react sortable props\n    list,\n    setList: setList,\n    children: children,\n    tag: tag,\n    style: style,\n    className: className,\n    clone: clone,\n    onAdd:\n    // sortable options that have methods we want to overwrite\n    onAdd,\n    onChange: onChange,\n    onChoose: onChoose,\n    onClone: onClone,\n    onEnd: onEnd,\n    onFilter: onFilter,\n    onRemove: onRemove,\n    onSort: onSort,\n    onStart: onStart,\n    onUnchoose: onUnchoose,\n    onUpdate: onUpdate,\n    onMove: onMove,\n    onSpill: onSpill,\n    onSelect: onSelect,\n    onDeselect: onDeselect,\n    ...options\n  } = props;\n  /* eslint-enable */\n  return options;\n}\n\n/** Holds a global reference for which react element is being dragged */ // @todo - use context to manage this. How does one use 2 different providers?\nconst $7fe8e3ea572bda7a$var$store = {\n  dragging: null\n};\nclass $7fe8e3ea572bda7a$export$11bbed9ee0012c13 extends (0, $8zHUo$react.Component) {\n  /* eslint-disable-next-line */static defaultProps = {\n    clone: item => item\n  };\n  constructor(props) {\n    super(props);\n    // @todo forward ref this component\n    this.ref = /*#__PURE__*/(0, $8zHUo$react.createRef)();\n    // make all state false because we can't change sortable unless a mouse gesture is made.\n    const newList = [...props.list].map(item => Object.assign(item, {\n      chosen: false,\n      selected: false\n    }));\n    props.setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n    (0, $parcel$interopDefault($8zHUo$tinyinvariant))(\n    //@ts-expect-error: Doesn't exist. Will deprecate soon.\n    !props.plugins, `\nPlugins prop is no longer supported.\nInstead, mount it with \"Sortable.mount(new MultiDrag())\"\nPlease read the updated README.md at https://github.com/SortableJS/react-sortablejs.\n      `);\n  }\n  componentDidMount() {\n    if (this.ref.current === null) return;\n    const newOptions = this.makeOptions();\n    (0, $parcel$interopDefault($8zHUo$sortablejs)).create(this.ref.current, newOptions);\n  }\n  componentDidUpdate(prevProps) {\n    if (prevProps.disabled !== this.props.disabled && this.sortable) this.sortable.option(\"disabled\", this.props.disabled);\n  }\n  render() {\n    const {\n      tag: tag,\n      style: style,\n      className: className,\n      id: id\n    } = this.props;\n    const classicProps = {\n      style: style,\n      className: className,\n      id: id\n    };\n    // if no tag, default to a `div` element.\n    const newTag = !tag || tag === null ? \"div\" : tag;\n    return /*#__PURE__*/(0, $8zHUo$react.createElement)(newTag, {\n      // @todo - find a way (perhaps with the callback) to allow AntD components to work\n      ref: this.ref,\n      ...classicProps\n    }, this.getChildren());\n  }\n  getChildren() {\n    const {\n      children: children,\n      dataIdAttr: dataIdAttr,\n      selectedClass = \"sortable-selected\",\n      chosenClass = \"sortable-chosen\",\n      /* eslint-disable */dragClass = \"sortable-drag\",\n      fallbackClass = \"sortable-falback\",\n      ghostClass = \"sortable-ghost\",\n      swapClass = \"sortable-swap-highlight\",\n      /* eslint-enable */filter = \"sortable-filter\",\n      list: list\n    } = this.props;\n    // if no children, don't do anything.\n    if (!children || children == null) return null;\n    const dataid = dataIdAttr || \"data-id\";\n    /* eslint-disable-next-line */\n    return (0, $8zHUo$react.Children).map(children, (child, index) => {\n      if (child === undefined) return undefined;\n      const item = list[index] || {};\n      const {\n        className: prevClassName\n      } = child.props;\n      // @todo - handle the function if avalable. I don't think anyone will be doing this soon.\n      const filtered = typeof filter === \"string\" && {\n        [filter.replace(\".\", \"\")]: !!item.filtered\n      };\n      const className = (0, $parcel$interopDefault($8zHUo$classnames))(prevClassName, {\n        [selectedClass]: item.selected,\n        [chosenClass]: item.chosen,\n        ...filtered\n      });\n      return /*#__PURE__*/(0, $8zHUo$react.cloneElement)(child, {\n        [dataid]: child.key,\n        className: className\n      });\n    });\n  }\n  /** Appends the `sortable` property to this component */\n  get sortable() {\n    const el = this.ref.current;\n    if (el === null) return null;\n    const key = Object.keys(el).find(k => k.includes(\"Sortable\"));\n    if (!key) return null;\n    //@ts-expect-error: fix me.\n    return el[key];\n  }\n  /** Converts all the props from `ReactSortable` into the `options` object that `Sortable.create(el, [options])` can use. */\n  makeOptions() {\n    const DOMHandlers = [\"onAdd\", \"onChoose\", \"onDeselect\", \"onEnd\", \"onRemove\", \"onSelect\", \"onSpill\", \"onStart\", \"onUnchoose\", \"onUpdate\"];\n    const NonDOMHandlers = [\"onChange\", \"onClone\", \"onFilter\", \"onSort\"];\n    const newOptions = (0, $eb03e74f8f7db1f3$export$7553c81e62e31b7e)(this.props);\n    DOMHandlers.forEach(name => newOptions[name] = this.prepareOnHandlerPropAndDOM(name));\n    NonDOMHandlers.forEach(name => newOptions[name] = this.prepareOnHandlerProp(name));\n    /** onMove has 2 arguments and needs to be handled seperately. */\n    const onMove1 = (evt, originalEvt) => {\n      const {\n        onMove: onMove\n      } = this.props;\n      const defaultValue = evt.willInsertAfter || -1;\n      if (!onMove) return defaultValue;\n      const result = onMove(evt, originalEvt, this.sortable, $7fe8e3ea572bda7a$var$store);\n      if (typeof result === \"undefined\") return false;\n      return result;\n    };\n    return {\n      ...newOptions,\n      onMove: onMove1\n    };\n  }\n  /** Prepares a method that will be used in the sortable options to call an `on[Handler]` prop & an `on[Handler]` ReactSortable method.  */\n  prepareOnHandlerPropAndDOM(evtName) {\n    return evt => {\n      // call the component prop\n      this.callOnHandlerProp(evt, evtName);\n      // calls state change\n      //@ts-expect-error: until @types multidrag item is in\n      this[evtName](evt);\n    };\n  }\n  /** Prepares a method that will be used in the sortable options to call an `on[Handler]` prop */\n  prepareOnHandlerProp(evtName) {\n    return evt => {\n      // call the component prop\n      this.callOnHandlerProp(evt, evtName);\n    };\n  }\n  /** Calls the `props.on[Handler]` function */\n  callOnHandlerProp(evt, evtName) {\n    const propEvent = this.props[evtName];\n    if (propEvent) propEvent(evt, this.sortable, $7fe8e3ea572bda7a$var$store);\n  }\n  // SORTABLE DOM HANDLING\n  onAdd(evt) {\n    const {\n      list: list,\n      setList: setList,\n      clone: clone\n    } = this.props;\n    /* eslint-disable-next-line */\n    const otherList = [...$7fe8e3ea572bda7a$var$store.dragging.props.list];\n    const customs = (0, $eb03e74f8f7db1f3$export$4655efe700f887a)(evt, otherList);\n    (0, $eb03e74f8f7db1f3$export$77f49a256021c8de)(customs);\n    const newList = (0, $eb03e74f8f7db1f3$export$eca851ee65ae17e4)(customs, list, evt, clone).map(item => Object.assign(item, {\n      selected: false\n    }));\n    setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n  }\n  onRemove(evt) {\n    const {\n      list: list,\n      setList: setList\n    } = this.props;\n    const mode = (0, $eb03e74f8f7db1f3$export$1fc0f6205829e19c)(evt);\n    const customs = (0, $eb03e74f8f7db1f3$export$4655efe700f887a)(evt, list);\n    (0, $eb03e74f8f7db1f3$export$a6177d5829f70ebc)(customs);\n    let newList = [...list];\n    // remove state if not in clone mode. otherwise, keep.\n    if (evt.pullMode !== \"clone\") newList = (0, $eb03e74f8f7db1f3$export$be2da95e6167b0bd)(customs, newList);else {\n      // switch used to get the clone\n      let customClones = customs;\n      switch (mode) {\n        case \"multidrag\":\n          customClones = customs.map((item, index) => ({\n            ...item,\n            element: evt.clones[index]\n          }));\n          break;\n        case \"normal\":\n          customClones = customs.map(item => ({\n            ...item,\n            element: evt.clone\n          }));\n          break;\n        case \"swap\":\n        default:\n          (0, $parcel$interopDefault($8zHUo$tinyinvariant))(true, `mode \"${mode}\" cannot clone. Please remove \"props.clone\" from <ReactSortable/> when using the \"${mode}\" plugin`);\n      }\n      (0, $eb03e74f8f7db1f3$export$77f49a256021c8de)(customClones);\n      // replace selected items with cloned items\n      customs.forEach(curr => {\n        const index = curr.oldIndex;\n        /* eslint-disable-next-line */\n        const newItem = this.props.clone(curr.item, evt);\n        newList.splice(index, 1, newItem);\n      });\n    }\n    // remove item.selected from list\n    newList = newList.map(item => Object.assign(item, {\n      selected: false\n    }));\n    setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n  }\n  onUpdate(evt) {\n    const {\n      list: list,\n      setList: setList\n    } = this.props;\n    const customs = (0, $eb03e74f8f7db1f3$export$4655efe700f887a)(evt, list);\n    (0, $eb03e74f8f7db1f3$export$77f49a256021c8de)(customs);\n    (0, $eb03e74f8f7db1f3$export$a6177d5829f70ebc)(customs);\n    const newList = (0, $eb03e74f8f7db1f3$export$c25cf8080bd305ec)(customs, list);\n    return setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n  }\n  onStart() {\n    $7fe8e3ea572bda7a$var$store.dragging = this;\n  }\n  onEnd() {\n    $7fe8e3ea572bda7a$var$store.dragging = null;\n  }\n  onChoose(evt) {\n    const {\n      list: list,\n      setList: setList\n    } = this.props;\n    const newList = list.map((item, index) => {\n      let newItem = item;\n      if (index === evt.oldIndex) newItem = Object.assign(item, {\n        chosen: true\n      });\n      return newItem;\n    });\n    setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n  }\n  onUnchoose(evt) {\n    const {\n      list: list,\n      setList: setList\n    } = this.props;\n    const newList = list.map((item, index) => {\n      let newItem = item;\n      if (index === evt.oldIndex) newItem = Object.assign(newItem, {\n        chosen: false\n      });\n      return newItem;\n    });\n    setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n  }\n  onSpill(evt) {\n    const {\n      removeOnSpill: removeOnSpill,\n      revertOnSpill: revertOnSpill\n    } = this.props;\n    if (removeOnSpill && !revertOnSpill) (0, $eb03e74f8f7db1f3$export$1d0aa160432dfea5)(evt.item);\n  }\n  onSelect(evt) {\n    const {\n      list: list,\n      setList: setList\n    } = this.props;\n    const newList = list.map(item => Object.assign(item, {\n      selected: false\n    }));\n    evt.newIndicies.forEach(curr => {\n      const index = curr.index;\n      if (index === -1) {\n        console.log(`\"${evt.type}\" had indice of \"${curr.index}\", which is probably -1 and doesn't usually happen here.`);\n        console.log(evt);\n        return;\n      }\n      newList[index].selected = true;\n    });\n    setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n  }\n  onDeselect(evt) {\n    const {\n      list: list,\n      setList: setList\n    } = this.props;\n    const newList = list.map(item => Object.assign(item, {\n      selected: false\n    }));\n    evt.newIndicies.forEach(curr => {\n      const index = curr.index;\n      if (index === -1) return;\n      newList[index].selected = true;\n    });\n    setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n  }\n}\nvar $faefaad95e5fcca0$exports = {};\n$parcel$exportWildcard(module.exports, $faefaad95e5fcca0$exports);","map":{"version":3,"names":["$eb03e74f8f7db1f3$export$1d0aa160432dfea5","node","parentElement","removeChild","$eb03e74f8f7db1f3$export$6d240faa51aa562f","parent","newChild","index","refChild","children","insertBefore","$eb03e74f8f7db1f3$export$d7d742816c28cf91","customs","$eb03e74f8f7db1f3$export$77f49a256021c8de","$eb03e74f8f7db1f3$export$a6177d5829f70ebc","forEach","curr","element","oldIndex","$eb03e74f8f7db1f3$export$4655efe700f887a","evt","list","mode","$eb03e74f8f7db1f3$export$1fc0f6205829e19c","from","custom","item","newIndex","drag","swap","swapItem","oldIndicies","map","multiDragElement","newIndicies","$eb03e74f8f7db1f3$export$bc06a3af7dc65f53","$eb03e74f8f7db1f3$export$c25cf8080bd305ec","normalized","a","$eb03e74f8f7db1f3$export$be2da95e6167b0bd","b","$eb03e74f8f7db1f3$export$eca851ee65ae17e4","newList","concat","reverse","splice","clone","newItem","length","inputs","sort","$eb03e74f8f7db1f3$export$7553c81e62e31b7e","props","setList","tag","style","className","onAdd","onChange","onChoose","onClone","onEnd","onFilter","onRemove","onSort","onStart","onUnchoose","onUpdate","onMove","onSpill","onSelect","onDeselect","options","$7fe8e3ea572bda7a$var$store","dragging","$7fe8e3ea572bda7a$export$11bbed9ee0012c13","$8zHUo$react","Component","defaultProps","constructor","ref","createRef","Object","assign","chosen","selected","sortable","$parcel$interopDefault","$8zHUo$tinyinvariant","plugins","componentDidMount","current","newOptions","makeOptions","$8zHUo$sortablejs","create","componentDidUpdate","prevProps","disabled","option","render","id","classicProps","newTag","createElement","getChildren","dataIdAttr","selectedClass","chosenClass","dragClass","fallbackClass","ghostClass","swapClass","filter","dataid","Children","child","undefined","prevClassName","filtered","replace","$8zHUo$classnames","cloneElement","key","el","keys","find","k","includes","DOMHandlers","NonDOMHandlers","name","prepareOnHandlerPropAndDOM","prepareOnHandlerProp","onMove1","originalEvt","defaultValue","willInsertAfter","result","evtName","callOnHandlerProp","propEvent","otherList","pullMode","customClones","clones","removeOnSpill","revertOnSpill","console","log","type"],"sources":["C:\\Users\\Hp\\OneDrive\\Desktop\\integration in react with node\\to-do-list\\client\\node_modules\\react-sortablejs\\dist\\src\\index.ts","C:\\Users\\Hp\\OneDrive\\Desktop\\integration in react with node\\to-do-list\\client\\node_modules\\react-sortablejs\\dist\\src\\react-sortable.tsx","C:\\Users\\Hp\\OneDrive\\Desktop\\integration in react with node\\to-do-list\\client\\node_modules\\react-sortablejs\\dist\\src\\util.ts","C:\\Users\\Hp\\OneDrive\\Desktop\\integration in react with node\\to-do-list\\client\\node_modules\\react-sortablejs\\dist\\src\\types.ts"],"sourcesContent":["export {\n  default as Sortable,\n  Direction,\n  DOMRect,\n  GroupOptions,\n  MoveEvent,\n  Options,\n  PullResult,\n  PutResult,\n  SortableEvent,\n  SortableOptions,\n  Utils,\n} from \"sortablejs\";\nexport { ReactSortable } from \"./react-sortable\";\nexport * from \"./types\";\n","import classNames from \"classnames\";\nimport {\n  Children,\n  cloneElement,\n  Component,\n  createElement,\n  createRef,\n  ReactElement,\n  RefObject,\n} from \"react\";\nimport Sortable, { MoveEvent, Options, SortableEvent } from \"sortablejs\";\nimport invariant from \"tiny-invariant\";\nimport {\n  AllMethodsExceptMove,\n  HandledMethodNames,\n  ItemInterface,\n  ReactSortableProps,\n  Store,\n  UnHandledMethodNames,\n} from \"./types\";\nimport {\n  createCustoms,\n  destructurePropsForOptions,\n  getMode,\n  handleStateAdd,\n  handleStateChanges,\n  handleStateRemove,\n  insertNodes,\n  removeNode,\n  removeNodes,\n} from \"./util\";\n\n/** Holds a global reference for which react element is being dragged */\n// @todo - use context to manage this. How does one use 2 different providers?\nconst store: Store = { dragging: null };\n\nexport class ReactSortable<T extends ItemInterface> extends Component<\n  ReactSortableProps<T>\n> {\n  /* eslint-disable-next-line */\n  static defaultProps: Partial<ReactSortableProps<any>> = {\n    clone: (item) => item,\n  };\n\n  private ref: RefObject<HTMLElement>;\n  constructor(props: ReactSortableProps<T>) {\n    super(props);\n    // @todo forward ref this component\n    this.ref = createRef<HTMLElement>();\n\n    // make all state false because we can't change sortable unless a mouse gesture is made.\n    const newList = [...props.list].map((item) =>\n      Object.assign(item, {\n        chosen: false,\n        selected: false,\n      })\n    );\n\n    props.setList(newList, this.sortable, store);\n    invariant(\n      //@ts-expect-error: Doesn't exist. Will deprecate soon.\n      !props.plugins,\n      `\nPlugins prop is no longer supported.\nInstead, mount it with \"Sortable.mount(new MultiDrag())\"\nPlease read the updated README.md at https://github.com/SortableJS/react-sortablejs.\n      `\n    );\n  }\n\n  componentDidMount(): void {\n    if (this.ref.current === null) return;\n    const newOptions = this.makeOptions();\n    Sortable.create(this.ref.current, newOptions);\n  }\n\n  componentDidUpdate(prevProps: ReactSortableProps<T>): void {\n    if (prevProps.disabled !== this.props.disabled && this.sortable) {\n      this.sortable.option(\"disabled\", this.props.disabled);\n    }\n  }\n\n  render(): JSX.Element {\n    const { tag, style, className, id } = this.props;\n    const classicProps = { style, className, id };\n\n    // if no tag, default to a `div` element.\n    const newTag = !tag || tag === null ? \"div\" : tag;\n    return createElement(\n      newTag,\n      {\n        // @todo - find a way (perhaps with the callback) to allow AntD components to work\n        ref: this.ref,\n        ...classicProps,\n      },\n      this.getChildren()\n    );\n  }\n\n  private getChildren() {\n    const {\n      children,\n      dataIdAttr,\n      selectedClass = \"sortable-selected\",\n      chosenClass = \"sortable-chosen\",\n      /* eslint-disable */\n      dragClass = \"sortable-drag\",\n      fallbackClass = \"sortable-falback\",\n      ghostClass = \"sortable-ghost\",\n      swapClass = \"sortable-swap-highlight\",\n      /* eslint-enable */\n      filter = \"sortable-filter\",\n      list,\n    } = this.props;\n\n    // if no children, don't do anything.\n    if (!children || children == null) return null;\n    const dataid = dataIdAttr || \"data-id\";\n    /* eslint-disable-next-line */\n    return Children.map(children as ReactElement<any>[], (child, index) => {\n      if (child === undefined) return undefined;\n\n      const item = list[index] || {};\n      const { className: prevClassName } = child.props;\n\n      // @todo - handle the function if avalable. I don't think anyone will be doing this soon.\n      const filtered = typeof filter === \"string\" && {\n        [filter.replace(\".\", \"\")]: !!item.filtered,\n      };\n\n      const className = classNames(prevClassName, {\n        [selectedClass]: item.selected,\n        [chosenClass]: item.chosen,\n        ...filtered,\n        // [dragClass]: true,\n        // [fallbackClass]: true,\n        // [ghostClass]: true,\n        // [swapClass]: true\n      });\n\n      return cloneElement(child, {\n        [dataid]: child.key,\n        className,\n      });\n    });\n  }\n\n  /** Appends the `sortable` property to this component */\n  private get sortable(): Sortable | null {\n    const el = this.ref.current;\n    if (el === null) return null;\n    const key = Object.keys(el).find((k) => k.includes(\"Sortable\"));\n    if (!key) return null;\n    //@ts-expect-error: fix me.\n    return el[key] as Sortable;\n  }\n\n  /** Converts all the props from `ReactSortable` into the `options` object that `Sortable.create(el, [options])` can use. */\n  makeOptions(): Options {\n    const DOMHandlers: HandledMethodNames[] = [\n      \"onAdd\",\n      \"onChoose\",\n      \"onDeselect\",\n      \"onEnd\",\n      \"onRemove\",\n      \"onSelect\",\n      \"onSpill\",\n      \"onStart\",\n      \"onUnchoose\",\n      \"onUpdate\",\n    ];\n    const NonDOMHandlers: UnHandledMethodNames[] = [\n      \"onChange\",\n      \"onClone\",\n      \"onFilter\",\n      \"onSort\",\n    ];\n    const newOptions: Options = destructurePropsForOptions(this.props);\n    DOMHandlers.forEach(\n      (name) => (newOptions[name] = this.prepareOnHandlerPropAndDOM(name))\n    );\n    NonDOMHandlers.forEach(\n      (name) => (newOptions[name] = this.prepareOnHandlerProp(name))\n    );\n\n    /** onMove has 2 arguments and needs to be handled seperately. */\n    const onMove = (evt: MoveEvent, originalEvt: Event) => {\n      const { onMove } = this.props;\n      const defaultValue = evt.willInsertAfter || -1;\n      if (!onMove) return defaultValue;\n      const result = onMove(evt, originalEvt, this.sortable, store);\n      if (typeof result === \"undefined\") return false;\n      return result;\n    };\n\n    return {\n      ...newOptions,\n      onMove,\n    };\n  }\n\n  /** Prepares a method that will be used in the sortable options to call an `on[Handler]` prop & an `on[Handler]` ReactSortable method.  */\n  prepareOnHandlerPropAndDOM(\n    evtName: HandledMethodNames\n  ): (evt: SortableEvent) => void {\n    return (evt) => {\n      // call the component prop\n      this.callOnHandlerProp(evt, evtName);\n      // calls state change\n      //@ts-expect-error: until @types multidrag item is in\n      this[evtName](evt);\n    };\n  }\n\n  /** Prepares a method that will be used in the sortable options to call an `on[Handler]` prop */\n  prepareOnHandlerProp(\n    evtName: Exclude<AllMethodsExceptMove, HandledMethodNames>\n  ): (evt: SortableEvent) => void {\n    return (evt) => {\n      // call the component prop\n      this.callOnHandlerProp(evt, evtName);\n    };\n  }\n\n  /** Calls the `props.on[Handler]` function */\n  callOnHandlerProp(evt: SortableEvent, evtName: AllMethodsExceptMove): void {\n    const propEvent = this.props[evtName];\n    if (propEvent) propEvent(evt, this.sortable, store);\n  }\n\n  // SORTABLE DOM HANDLING\n\n  onAdd(evt: MultiDragEvent): void {\n    const { list, setList, clone } = this.props;\n    /* eslint-disable-next-line */\n    const otherList = [...store.dragging!.props.list];\n    const customs = createCustoms(evt, otherList);\n    removeNodes(customs);\n\n    const newList = handleStateAdd(customs, list, evt, clone).map((item) =>\n      Object.assign(item, {\n        selected: false,\n      })\n    );\n\n    setList(newList, this.sortable, store);\n  }\n\n  onRemove(evt: MultiDragEvent): void {\n    const { list, setList } = this.props;\n    const mode = getMode(evt);\n    const customs = createCustoms(evt, list);\n    insertNodes(customs);\n\n    let newList = [...list];\n    // remove state if not in clone mode. otherwise, keep.\n    if (evt.pullMode !== \"clone\") newList = handleStateRemove(customs, newList);\n    // if clone, it doesn't really remove. instead it clones in place.\n    // @todo -\n    else {\n      // switch used to get the clone\n      let customClones = customs;\n      switch (mode) {\n        case \"multidrag\":\n          customClones = customs.map((item, index) => ({\n            ...item,\n            element: evt.clones[index],\n          }));\n          break;\n        case \"normal\":\n          customClones = customs.map((item) => ({\n            ...item,\n            element: evt.clone,\n          }));\n          break;\n        case \"swap\":\n        default: {\n          invariant(\n            true,\n            `mode \"${mode}\" cannot clone. Please remove \"props.clone\" from <ReactSortable/> when using the \"${mode}\" plugin`\n          );\n        }\n      }\n      removeNodes(customClones);\n\n      // replace selected items with cloned items\n      customs.forEach((curr) => {\n        const index = curr.oldIndex;\n        /* eslint-disable-next-line */\n        const newItem = this.props.clone!(curr.item, evt);\n        newList.splice(index, 1, newItem);\n      });\n    }\n\n    // remove item.selected from list\n    newList = newList.map((item: T) =>\n      Object.assign(item, {\n        selected: false,\n      })\n    );\n\n    setList(newList, this.sortable, store);\n  }\n\n  onUpdate(evt: MultiDragEvent): void {\n    const { list, setList } = this.props;\n    const customs = createCustoms(evt, list);\n    removeNodes(customs);\n    insertNodes(customs);\n    const newList = handleStateChanges(customs, list);\n    return setList(newList, this.sortable, store);\n  }\n\n  onStart(): void {\n    store.dragging = this;\n  }\n\n  onEnd(): void {\n    store.dragging = null;\n  }\n\n  onChoose(evt: SortableEvent): void {\n    const { list, setList } = this.props;\n    const newList = list.map((item, index) => {\n      let newItem = item;\n      if (index === evt.oldIndex) {\n        newItem = Object.assign(item, {\n          chosen: true,\n        });\n      }\n      return newItem;\n    });\n    setList(newList, this.sortable, store);\n  }\n\n  onUnchoose(evt: SortableEvent): void {\n    const { list, setList } = this.props;\n    const newList = list.map((item, index) => {\n      let newItem = item;\n      if (index === evt.oldIndex) {\n        newItem = Object.assign(newItem, {\n          chosen: false,\n        });\n      }\n      return newItem;\n    });\n    setList(newList, this.sortable, store);\n  }\n\n  onSpill(evt: SortableEvent): void {\n    const { removeOnSpill, revertOnSpill } = this.props;\n    if (removeOnSpill && !revertOnSpill) removeNode(evt.item);\n  }\n\n  onSelect(evt: MultiDragEvent): void {\n    const { list, setList } = this.props;\n    const newList = list.map((item) =>\n      Object.assign(item, {\n        selected: false,\n      })\n    );\n\n    evt.newIndicies.forEach((curr) => {\n      const index = curr.index;\n      if (index === -1) {\n        console.log(\n          `\"${evt.type}\" had indice of \"${curr.index}\", which is probably -1 and doesn't usually happen here.`\n        );\n        console.log(evt);\n        return;\n      }\n      newList[index].selected = true;\n    });\n    setList(newList, this.sortable, store);\n  }\n\n  onDeselect(evt: MultiDragEvent): void {\n    const { list, setList } = this.props;\n    const newList = list.map((item) =>\n      Object.assign(item, {\n        selected: false,\n      })\n    );\n    evt.newIndicies.forEach((curr) => {\n      const index = curr.index;\n      if (index === -1) return;\n      newList[index].selected = true;\n    });\n    setList(newList, this.sortable, store);\n  }\n}\n\n// everything below this point can be removed\n// once @types has been merged. PR submited\ninterface MultiIndices {\n  multiDragElement: HTMLElement;\n  index: number;\n}\n\nexport interface MultiDragEvent extends SortableEvent {\n  // @todo - add this to @types\n  clones: HTMLElement[];\n  oldIndicies: MultiIndices[];\n  newIndicies: MultiIndices[];\n  swapItem: HTMLElement | null;\n}\n","import { PropsWithChildren } from \"react\";\nimport Sortable, { Options } from \"sortablejs\";\nimport { MultiDragEvent } from \"./react-sortable\";\nimport { AllMethodNames, ItemInterface, ReactSortableProps } from \"./types\";\n\n/**\n * Removes the `node` from the DOM\n * @param node\n */\nexport function removeNode(node: HTMLElement): void {\n  if (node.parentElement !== null) node.parentElement.removeChild(node);\n}\n\n/**\n * Inserts the `newChild` node at the given index in a parent\n * @param parent The parent HTML Element.\n * @param newChild A HTML eement to add as a child of the parent.\n * @param index index of the parent to place the new child in.\n */\nexport function insertNodeAt(\n  parent: HTMLElement,\n  newChild: HTMLElement,\n  index: number\n): void {\n  const refChild = parent.children[index] || null;\n  parent.insertBefore(newChild, refChild);\n}\n\n// @todo - create a dom handler function for arrays or not at all\n\n/** removes stuff from the dom in a nice order */\n// @todo - do I need parenElement?\nexport function handleDOMChanges<T extends ItemInterface>(\n  customs: Normalized<T>[]\n): void {\n  removeNodes(customs);\n  insertNodes(customs);\n}\n\nexport function removeNodes<T extends ItemInterface>(\n  customs: Normalized<T>[]\n): void {\n  customs.forEach((curr) => removeNode(curr.element));\n}\n\nexport function insertNodes<T extends ItemInterface>(\n  customs: Normalized<T>[]\n): void {\n  customs.forEach((curr) => {\n    insertNodeAt(curr.parentElement, curr.element, curr.oldIndex);\n  });\n}\n\nexport function createCustoms<T extends ItemInterface>(\n  evt: MultiDragEvent,\n  list: T[]\n): Normalized<T>[] {\n  const mode = getMode(evt);\n  const parentElement = { parentElement: evt.from };\n  let custom = [];\n  switch (mode) {\n    case \"normal\":\n      /* eslint-disable */\n      const item = {\n        element: evt.item,\n        newIndex: evt.newIndex!,\n        oldIndex: evt.oldIndex!,\n        parentElement: evt.from,\n      };\n      custom = [item];\n      break;\n    case \"swap\":\n      const drag: Input = {\n        element: evt.item,\n        oldIndex: evt.oldIndex!,\n        newIndex: evt.newIndex!,\n        ...parentElement,\n      };\n      const swap: Input = {\n        element: evt.swapItem!,\n        oldIndex: evt.newIndex!,\n        newIndex: evt.oldIndex!,\n        ...parentElement,\n      };\n      custom = [drag, swap];\n      break;\n    case \"multidrag\":\n      custom = evt.oldIndicies.map<Input>((curr, index) => ({\n        element: curr.multiDragElement,\n        oldIndex: curr.index,\n        newIndex: evt.newIndicies[index].index,\n        ...parentElement,\n      }));\n      break;\n  }\n  /* eslint-enable */\n\n  const customs = createNormalized(custom, list);\n  return customs;\n}\n\n/** moves items form old index to new index without breaking anything ideally. */\nexport function handleStateChanges<T extends ItemInterface>(\n  normalized: Normalized<T>[],\n  list: T[]\n): T[] {\n  const a = handleStateRemove(normalized, list);\n  const b = handleStateAdd(normalized, a);\n  return b;\n}\n\nexport function handleStateRemove<T extends ItemInterface>(\n  normalized: Normalized<T>[],\n  list: T[]\n): T[] {\n  const newList = [...list];\n  normalized\n    .concat()\n    .reverse()\n    .forEach((curr) => newList.splice(curr.oldIndex, 1));\n  return newList;\n}\n\nexport function handleStateAdd<T extends ItemInterface>(\n  normalized: Normalized<T>[],\n  list: T[],\n  evt?: Sortable.SortableEvent,\n  clone?: ((currentItem: T, evt: Sortable.SortableEvent) => T) | undefined\n): T[] {\n  const newList = [...list];\n  normalized.forEach((curr) => {\n    const newItem = clone && evt && clone(curr.item, evt);\n    newList.splice(curr.newIndex, 0, newItem || curr.item);\n  });\n  return newList;\n}\n\nexport function getMode(evt: MultiDragEvent): \"multidrag\" | \"swap\" | \"normal\" {\n  if (evt.oldIndicies && evt.oldIndicies.length > 0) return \"multidrag\";\n  if (evt.swapItem) return \"swap\";\n  return \"normal\";\n}\n\nexport function createNormalized<T extends ItemInterface>(\n  inputs: Input[],\n  list: T[]\n): Normalized<T>[] {\n  const normalized = inputs\n    .map<Normalized<T>>((curr) => ({ ...curr, item: list[curr.oldIndex] }))\n    .sort((a, b) => a.oldIndex - b.oldIndex);\n  return normalized;\n}\n\nexport interface Input {\n  parentElement: HTMLElement;\n  element: HTMLElement;\n  oldIndex: number;\n  newIndex: number;\n}\n\nexport interface Normalized<T> extends Input {\n  item: T;\n}\n\n/**\n * Removes the following group of properties from `props`,\n * leaving only `Sortable.Options` without any `on` methods.\n * @param props `ReactSortable.Props`\n */\nexport function destructurePropsForOptions<T>(\n  props: PropsWithChildren<ReactSortableProps<T>>\n): Exclude<Options, AllMethodNames> {\n  /* eslint-disable */\n  const {\n    // react sortable props\n    list,\n    setList,\n    children,\n    tag,\n    style,\n    className,\n    clone,\n    // sortable options that have methods we want to overwrite\n    onAdd,\n    onChange,\n    onChoose,\n    onClone,\n    onEnd,\n    onFilter,\n    onRemove,\n    onSort,\n    onStart,\n    onUnchoose,\n    onUpdate,\n    onMove,\n    onSpill,\n    onSelect,\n    onDeselect,\n    ...options\n  } = props;\n  /* eslint-enable */\n  return options;\n}\n\n/**\n * Construct a type with the properties of T except for those in type K.\n * Including this allows for backwards compatibility with earlier versions of TS.\n */\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n","import {\n  CSSProperties,\n  ForwardRefExoticComponent,\n  ReactHTML,\n  ReactNode,\n  RefAttributes,\n} from \"react\";\nimport Sortable, { MoveEvent, Options, SortableEvent } from \"sortablejs\";\nimport { ReactSortable } from \"./react-sortable\";\nimport { Omit } from \"./util\";\n\n// @todo: remove dynamic types and create declarative types instead for readability of user.\n// add these in docs as well\nexport interface ItemInterface {\n  /** The unique id associated with your item. It's recommended this is the same as the key prop for your list item. */\n  id: string | number;\n  /** When true, the item is selected using MultiDrag */\n  selected?: boolean;\n  /** When true, the item is deemed \"chosen\", which basically just a mousedown event. */\n  chosen?: boolean;\n  /** When true, it will not be possible to pick this item up in the list. */\n  filtered?: boolean;\n  /* eslint-disable-next-line */\n  [property: string]: any;\n}\n\nexport interface ReactSortableProps<T>\n  extends ReactSortableOptions,\n    Omit<Options, AllMethodNames> {\n  /**\n   * The list of items to use.\n   */\n  list: T[];\n  /**\n   * Sets the state for your list of items.\n   */\n  setList: (newState: T[], sortable: Sortable | null, store: Store) => void;\n  /**\n   * If parsing in a component WITHOUT a ref, an error will be thrown.\n   *\n   * To fix this, use the `forwardRef` component.\n   *\n   * @example\n   * forwardRef<HTMLElement, YOURPROPS>((props, ref) => <button {...props} ref={ref} />)\n   */\n  /* eslint-disable-next-line */\n  tag?: ForwardRefExoticComponent<RefAttributes<any>> | keyof ReactHTML;\n  /**\n   * If this is provided, the function will replace the clone in place.\n   *\n   * When an is moved from `A` to `B` with `pull: 'clone'`,\n   * the original element will be moved to `B`\n   * and the new clone will be placed in `A`\n   */\n  clone?: (currentItem: T, evt: SortableEvent) => T;\n\n  // other classic DOM attributes.\n  style?: CSSProperties;\n  className?: string;\n  id?: string;\n  children?: ReactNode;\n}\n\n/**\n * Holds the react component as a reference so we can access it's store.\n *\n * Mainly used to access `props.list` within another components.\n */\nexport interface Store {\n  /* eslint-disable-next-line */\n  dragging: null | ReactSortable<any>;\n}\n\n//\n// TYPES FOR METHODS\n//\n\n/**\n * Change the `on[...]` methods in Sortable.Options,\n * so that they all have an extra arg that is `store: Store`\n */\nexport type ReactSortableOptions = Partial<\n  Record<\n    AllMethodsExceptMove,\n    (evt: SortableEvent, sortable: Sortable | null, store: Store) => void\n  >\n> & {\n  /**\n   * The default sortable behaviour has been changed.\n   *\n   * If the return value is void, then the defaults will kick in.\n   * it saves the user trying to figure it out.\n   * and they can just use onmove as a callback value\n   */\n  onMove?: (\n    evt: MoveEvent,\n    originalEvent: Event,\n    sortable: Sortable | null,\n    store: Store\n  ) => boolean | -1 | 1 | void;\n};\n\n// STRINGS\n\n/** All method names starting with `on` in `Sortable.Options` */\nexport type AllMethodNames =\n  | \"onAdd\"\n  | \"onChange\"\n  | \"onChoose\"\n  | \"onClone\"\n  | \"onEnd\"\n  | \"onFilter\"\n  | \"onMove\"\n  | \"onRemove\"\n  | \"onSort\"\n  | \"onSpill\"\n  | \"onStart\"\n  | \"onUnchoose\"\n  | \"onUpdate\"\n  | \"onSelect\"\n  | \"onDeselect\";\n\n/** Method names that fire in `this`, when this is react-sortable */\nexport type HandledMethodNames =\n  | \"onAdd\"\n  | \"onRemove\"\n  | \"onUpdate\"\n  | \"onStart\"\n  | \"onEnd\"\n  | \"onSpill\"\n  | \"onSelect\"\n  | \"onDeselect\"\n  | \"onChoose\"\n  | \"onUnchoose\";\n\nexport type UnHandledMethodNames = Exclude<\n  AllMethodsExceptMove,\n  HandledMethodNames | \"onMove\"\n>;\n\n/**\n * Same as `SortableMethodKeys` type but with out the string `onMove`.\n */\nexport type AllMethodsExceptMove = Exclude<AllMethodNames, \"onMove\">;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}